import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext
import serial
import serial.tools.list_ports
import threading
import time
import csv
import json
from datetime import datetime
import struct

class PortMonitor:
    def __init__(self, master, port_name):
        self.master = master
        self.master.title(f"{port_name}")
        
        # MUCH smaller window
        self.master.geometry("480x360")

        self.port_name = port_name
        self.running = False
        self.serial_port = None
        self.data_buffer = []

        # Smaller text area
        self.text = scrolledtext.ScrolledText(master, width=50, height=12, font=("Consolas", 9))
        self.text.grid(row=0, column=0, columnspan=4, padx=5, pady=5)

        self.btn_start = tk.Button(master, text="Start", width=10, command=self.start_reading)
        self.btn_start.grid(row=1, column=0, pady=3)

        self.btn_stop = tk.Button(master, text="Stop", width=10, command=self.stop_reading)
        self.btn_stop.grid(row=1, column=1, pady=3)

        self.btn_export_csv = tk.Button(master, text="CSV", width=10, command=self.export_csv)
        self.btn_export_csv.grid(row=2, column=0, pady=3)

        self.btn_export_json = tk.Button(master, text="JSON", width=10, command=self.export_json)
        self.btn_export_json.grid(row=2, column=1, pady=3)

        self.btn_export_bin = tk.Button(master, text="BIN", width=10, command=self.export_binary)
        self.btn_export_bin.grid(row=2, column=2, pady=3)

    def start_reading(self):
        try:
            self.serial_port = serial.Serial(self.port_name, 115200, timeout=1)
            self.running = True
            threading.Thread(target=self.read_data, daemon=True).start()
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def stop_reading(self):
        self.running = False
        if self.serial_port and self.serial_port.is_open:
            self.serial_port.close()

    def read_data(self):
        while self.running:
            try:
                if self.serial_port.in_waiting:
                    line = self.serial_port.readline().decode("utf-8", errors="ignore").strip()
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Color coding
                    if "TEMP" in line.upper():
                        color = "red"
                    elif "HUM" in line.upper():
                        color = "blue"
                    elif "VIB" in line.upper():
                        color = "green"
                    else:
                        color = "black"

                    self.text.insert(tk.END, f"{timestamp} | {line}\n", color)
                    self.text.tag_config(color, foreground=color)
                    self.text.see(tk.END)

                    self.data_buffer.append({"time": timestamp, "data": line})

            except:
                pass

            time.sleep(0.02)

    def export_csv(self):
        if not self.data_buffer:
            messagebox.showwarning("Warning", "No data to export")
            return

        file_path = filedialog.asksaveasfilename(defaultextension=".csv",
                                                 filetypes=[("CSV Files", "*.csv")])
        if not file_path:
            return

        with open(file_path, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["time", "data"])
            for row in self.data_buffer:
                writer.writerow([row["time"], row["data"]])

        messagebox.showinfo("Saved", "CSV Export Complete!")

    def export_json(self):
        if not self.data_buffer:
            messagebox.showwarning("Warning", "No data to export")
            return

        file_path = filedialog.asksaveasfilename(defaultextension=".json",
                                                 filetypes=[("JSON Files", "*.json")])
        if not file_path:
            return

        with open(file_path, "w") as f:
            json.dump(self.data_buffer, f, indent=4)

        messagebox.showinfo("Saved", "JSON Export Complete!")

    def export_binary(self):
        if not self.data_buffer:
            messagebox.showwarning("Warning", "No data to export")
            return

        file_path = filedialog.asksaveasfilename(defaultextension=".bin",
                                                 filetypes=[("Binary Files", "*.bin")])
        if not file_path:
            return

        with open(file_path, "wb") as f:
            for row in self.data_buffer:
                time_b = row["time"].encode("utf-8")
                data_b = row["data"].encode("utf-8")

                f.write(struct.pack("H", len(time_b)))
                f.write(time_b)
                f.write(struct.pack("H", len(data_b)))
                f.write(data_b)

        messagebox.showinfo("Saved", "Binary Export Complete!")


class App:
    def __init__(self, root):
        self.root = root
        self.root.title("Serial Ports")

        # Tiny main window
        self.root.geometry("220x300")

        tk.Label(root, text="Ports:").grid(row=0, column=0, padx=5, pady=5)

        self.port_listbox = tk.Listbox(root, height=12, width=20)
        self.port_listbox.grid(row=1, column=0, padx=5)

        self.refresh_btn = tk.Button(root, text="Refresh", width=14, command=self.refresh_ports)
        self.refresh_btn.grid(row=2, column=0, pady=5)

        self.open_btn = tk.Button(root, text="Open", width=14, command=self.open_port_window)
        self.open_btn.grid(row=3, column=0, pady=5)

        self.refresh_ports()

    def refresh_ports(self):
        self.port_listbox.delete(0, tk.END)
        ports = serial.tools.list_ports.comports()
        for p in ports:
            self.port_listbox.insert(tk.END, p.device)

    def open_port_window(self):
        selected = self.port_listbox.curselection()
        if not selected:
            messagebox.showwarning("Warning", "Select a COM port first")
            return

        port_name = self.port_listbox.get(selected[0])
        win = tk.Toplevel(self.root)
        PortMonitor(win, port_name)


root = tk.Tk()
app = App(root)
root.mainloop()
